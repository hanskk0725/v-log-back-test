@startuml post-list
title 게시글 목록 조회 (GET /api/v1/posts)

actor Client
participant "PostController" as Controller
participant "PostService" as Service
participant "PostRepository" as PostRepo

Client -> Controller: GET /api/v1/posts\n?page=0&size=10&tag=Spring&blogId=1

Controller -> Service: getPosts(tag, blogId, pageable)

alt tag != null && blogId != null
    Service -> PostRepo: findAllByTagNameAndBlogId(tag, blogId, pageable)
else tag != null
    Service -> PostRepo: findAllByTagName(tag, pageable)
else blogId != null
    Service -> PostRepo: findAllByBlogId(blogId, pageable)
else 필터 없음
    Service -> PostRepo: findAll(pageable)
end

PostRepo --> Service: Page<Post>

loop 각 Post에 대해
    Service -> Service: getTagNames(post)
    note right: Post -> TagMap -> Tag\n경로로 태그명 추출
    Service -> Service: PostListResponse.of(post, tags)
end

Service --> Controller: PageResponse<PostListResponse>
Controller --> Client: 200 OK + JSON

note over Client
{
  "content": [...],
  "pageInfo": {
    "page": 0,
    "size": 10,
    "totalElements": 100,
    "totalPages": 10,
    "first": true,
    "last": false
  }
}
end note

@enduml

@startuml post-detail
title 게시글 상세 조회 (GET /api/v1/posts/{postId})

actor Client
participant "PostController" as Controller
participant "PostService" as Service
participant "PostRepository" as PostRepo

Client -> Controller: GET /api/v1/posts/1

Controller -> Service: getPost(postId)

Service -> PostRepo: findById(postId)

alt 게시글 없음
    PostRepo --> Service: Optional.empty()
    Service -> Service: throw NotFoundException.post(postId)
    Service --> Controller: NotFoundException
    Controller --> Client: 404 Not Found
    note over Client
    {
      "status": 404,
      "error": "Not Found",
      "message": "게시글을 찾을 수 없습니다. id=1",
      "timestamp": "2025-12-25T12:00:00"
    }
    end note
else 게시글 존재
    PostRepo --> Service: Post

    Service -> Service: getTagNames(post)
    Service -> Service: PostResponse.of(post, tags)

    Service --> Controller: PostResponse
    Controller --> Client: 200 OK + JSON
    note over Client
    {
      "postId": 1,
      "title": "제목",
      "content": "내용",
      "author": { "userId": 1, "nickname": "작성자" },
      "tags": ["Spring", "JPA"],
      "createdAt": "2025-12-25T12:00:00",
      "updatedAt": "2025-12-25T12:00:00"
    }
    end note
end

@enduml

@startuml post-create
title 게시글 작성 (POST /api/v1/posts)

actor Client
participant "SecurityFilter" as Security
participant "PostController" as Controller
participant "PostService" as Service
participant "UserRepository" as UserRepo
participant "BlogRepository" as BlogRepo
participant "PostRepository" as PostRepo
participant "TagRepository" as TagRepo
participant "TagMapRepository" as TagMapRepo

Client -> Security: POST /api/v1/posts\n(with session cookie)
note over Client
Request Body:
{
  "title": "제목",
  "content": "내용",
  "tags": ["Spring", "JPA"]
}
end note

Security -> Security: 인증 확인\n(SecurityContext)

alt 인증 실패
    Security --> Client: 401 Unauthorized
    note over Client
    {
      "message": "인증되지 않았습니다.",
      "status": "401",
      "path": "/api/v1/posts",
      "timestamp": "..."
    }
    end note
else 인증 성공
    Security -> Controller: @AuthenticationPrincipal UserDetails

    Controller -> Controller: userDetails.getUsername()
    note right: email 추출

    Controller -> Service: createPost(request, email)

    == 사용자 및 블로그 조회 ==
    Service -> UserRepo: findByEmail(email)

    alt 사용자 없음
        UserRepo --> Service: Optional.empty()
        Service -> Service: throw NotFoundException.user(email)
        Service --> Controller: NotFoundException
        Controller --> Client: 404 Not Found
    else 사용자 존재
        UserRepo --> Service: User
    end

    Service -> BlogRepo: findByUser(user)

    alt 블로그 없음
        BlogRepo --> Service: Optional.empty()
        Service -> Service: throw NotFoundException.blog(userId)
        Service --> Controller: NotFoundException
        Controller --> Client: 404 Not Found
    else 블로그 존재
        BlogRepo --> Service: Blog
    end

    == 게시글 생성 ==
    Service -> Service: Post.create(title, content, blog)
    note right: 정적 팩토리 메서드 사용

    Service -> PostRepo: save(post)
    PostRepo --> Service: Post (with ID)

    == 태그 저장 ==
    loop 각 태그명에 대해
        Service -> TagRepo: findByTitle(tagName)
        alt 태그 존재
            TagRepo --> Service: Tag
        else 태그 없음
            Service -> Service: Tag.create(tagName)
            Service -> TagRepo: save(tag)
            TagRepo --> Service: Tag (new)
        end
        Service -> Service: TagMap.create(post, tag)
        Service -> TagMapRepo: save(tagMap)
    end

    Service -> Service: PostResponse.of(post, tagNames)
    Service --> Controller: PostResponse
    Controller --> Client: 201 Created + JSON
end

@enduml

@startuml post-update
title 게시글 수정 (PUT /api/v1/posts/{postId})

actor Client
participant "SecurityFilter" as Security
participant "PostController" as Controller
participant "PostService" as Service
participant "PostRepository" as PostRepo
participant "TagMapRepository" as TagMapRepo
participant "TagRepository" as TagRepo

Client -> Security: PUT /api/v1/posts/1\n(with session cookie)
note over Client
Request Body:
{
  "title": "수정된 제목",
  "content": "수정된 내용",
  "tags": ["Spring", "JPA", "Security"]
}
end note

Security -> Security: 인증 확인

alt 인증 실패
    Security --> Client: 401 Unauthorized
else 인증 성공
    Security -> Controller: @AuthenticationPrincipal UserDetails

    Controller -> Controller: userDetails.getUsername()
    Controller -> Service: updatePost(postId, request, email)

    == 게시글 조회 ==
    Service -> PostRepo: findById(postId)

    alt 게시글 없음
        PostRepo --> Service: Optional.empty()
        Service -> Service: throw NotFoundException.post(postId)
        Service --> Controller: NotFoundException
        Controller --> Client: 404 Not Found
    else 게시글 존재
        PostRepo --> Service: Post

        == 권한 검증 ==
        Service -> Service: post.getBlog().getUser().getEmail()
        note right: Post -> Blog -> User\n경로로 작성자 이메일 확인

        alt email 불일치 (작성자 아님)
            Service -> Service: throw ForbiddenException.postUpdate()
            Service --> Controller: ForbiddenException
            Controller --> Client: 403 Forbidden
            note over Client
            {
              "status": 403,
              "error": "Forbidden",
              "message": "게시글 수정 권한이 없습니다.",
              "timestamp": "..."
            }
            end note
        else email 일치 (작성자 본인)
            == 게시글 수정 ==
            Service -> Service: post.update(title, content)
            note right: Dirty Checking으로\n자동 UPDATE

            == 태그 업데이트 ==
            Service -> TagMapRepo: deleteAllByPost(post)
            note right: @Modifying @Query\n벌크 삭제

            loop 새 태그 저장
                Service -> TagRepo: findByTitle(tagName)
                alt 태그 존재
                    TagRepo --> Service: Tag
                else 태그 없음
                    Service -> TagRepo: save(Tag.create(tagName))
                    TagRepo --> Service: Tag (new)
                end
                Service -> TagMapRepo: save(TagMap.create(post, tag))
            end

            Service -> Service: PostResponse.of(post, tagNames)
            Service --> Controller: PostResponse
            Controller --> Client: 200 OK + JSON
        end
    end
end

@enduml

@startuml post-delete
title 게시글 삭제 (DELETE /api/v1/posts/{postId})

actor Client
participant "SecurityFilter" as Security
participant "PostController" as Controller
participant "PostService" as Service
participant "PostRepository" as PostRepo
participant "TagMapRepository" as TagMapRepo

Client -> Security: DELETE /api/v1/posts/1\n(with session cookie)
Security -> Security: 인증 확인

alt 인증 실패
    Security --> Client: 401 Unauthorized
else 인증 성공
    Security -> Controller: @AuthenticationPrincipal UserDetails

    Controller -> Controller: userDetails.getUsername()
    Controller -> Service: deletePost(postId, email)

    == 게시글 조회 ==
    Service -> PostRepo: findById(postId)

    alt 게시글 없음
        PostRepo --> Service: Optional.empty()
        Service -> Service: throw NotFoundException.post(postId)
        Service --> Controller: NotFoundException
        Controller --> Client: 404 Not Found
    else 게시글 존재
        PostRepo --> Service: Post

        == 권한 검증 ==
        Service -> Service: post.getBlog().getUser().getEmail()

        alt email 불일치 (작성자 아님)
            Service -> Service: throw ForbiddenException.postDelete()
            Service --> Controller: ForbiddenException
            Controller --> Client: 403 Forbidden
            note over Client
            {
              "status": 403,
              "error": "Forbidden",
              "message": "게시글 삭제 권한이 없습니다.",
              "timestamp": "..."
            }
            end note
        else email 일치 (작성자 본인)
            == 연관 데이터 삭제 ==
            Service -> TagMapRepo: deleteAllByPost(post)
            note right: FK 제약조건 해결을 위해\nTagMap 먼저 삭제

            == 게시글 삭제 ==
            Service -> PostRepo: delete(post)

            Service --> Controller: void
            Controller --> Client: 204 No Content
        end
    end
end

@enduml

@startuml class-diagram
title V-Log 클래스 다이어그램 (Entity 관계)

package "Entity" {
    abstract class BaseEntity {
        -LocalDateTime createdAt
        -LocalDateTime updatedAt
    }

    class User {
        -Long id
        -String email
        -String password
        -String nickname
        +{static} of(dto, encoder): User
    }

    class Blog {
        -Long id
        -String title
    }

    class Post {
        -Long id
        -String title
        -String content
        -int viewCount
        +{static} create(title, content, blog): Post
        +update(title, content): void
    }

    class Comment {
        -Long id
        -String content
        +{static} create(user, post, content): Comment
        +{static} createReply(user, post, parent, content): Comment
        +update(content): void
    }

    class Tag {
        -Long id
        -String title
        +{static} create(title): Tag
    }

    class TagMap {
        -Long id
        +{static} create(post, tag): TagMap
    }

    class Like {
        -Long id
        +{static} create(user, post): Like
    }

    class Follow {
        -Long id
        +{static} create(follower, following): Follow
    }
}

BaseEntity <|-- Blog
BaseEntity <|-- Post
BaseEntity <|-- Comment
BaseEntity <|-- Tag
BaseEntity <|-- TagMap
BaseEntity <|-- Like
BaseEntity <|-- Follow

User "1" -- "1" Blog : has >
Blog "1" -- "*" Post : contains >
Post "1" -- "*" TagMap : has >
Tag "1" -- "*" TagMap : mapped by <
Post "1" -- "*" Comment : has >
User "1" -- "*" Comment : writes >
Comment "1" -- "*" Comment : parent-child >
User "1" -- "*" Like : likes >
Post "1" -- "*" Like : liked by <
User "1" -- "*" Follow : follower >
User "1" -- "*" Follow : following >

@enduml

@startuml auth-signup
title 회원가입 (POST /auth/signup)

actor Client
participant "AuthController" as Controller
participant "AuthService" as Service
participant "UserRepository" as UserRepo
database DB

Client -> Controller: POST /auth/signup
note over Client
Request Body:
{
  "email": "user@example.com",
  "password": "password123",
  "nickname": "홍길동"
}
end note

Controller -> Service: signup(dto)

Service -> UserRepo: existsByEmail(email)
UserRepo -> DB: SELECT EXISTS(...)
DB --> UserRepo: true/false

alt 이메일 중복
    UserRepo --> Service: true
    Service -> Service: throw IllegalArgumentException
    note right: TODO: DuplicateException.email() 사용
    Service --> Controller: IllegalArgumentException
    Controller --> Client: 500 Internal Server Error
    note right: TODO: 409 Conflict
else 이메일 사용 가능
    UserRepo --> Service: false

    Service -> Service: User.of(dto, passwordEncoder)
    note right: 비밀번호 암호화\nBCrypt 사용

    Service -> UserRepo: save(user)
    note right: @PrePersist에서\nBlog 자동 생성
    UserRepo -> DB: INSERT INTO users...\nINSERT INTO blogs...
    DB --> UserRepo: User (with ID)
    UserRepo --> Service: User

    Service -> Service: UserDto.of(user)
    Service --> Controller: UserDto
    Controller --> Client: 200 OK + JSON
end

@enduml

@startuml auth-login
title 로그인 (POST /auth/login)

actor Client
participant "AuthController" as Controller
participant "AuthenticationManager" as AuthManager
participant "AuthService" as Service
participant "UserRepository" as UserRepo
participant "SecurityContext" as Security
database DB

Client -> Controller: POST /auth/login
note over Client
Request Body:
{
  "email": "user@example.com",
  "password": "password123"
}
end note

Controller -> Controller: UsernamePasswordAuthenticationToken\n생성 (email, password)

Controller -> AuthManager: authenticate(token)

AuthManager -> Service: loadUserByUsername(email)
note right: UserDetailsService 구현

Service -> UserRepo: findByEmail(email)
UserRepo -> DB: SELECT * FROM users WHERE email = ?

alt 사용자 없음
    DB --> UserRepo: empty
    UserRepo --> Service: Optional.empty()
    Service -> Service: throw UsernameNotFoundException
    Service --> AuthManager: UsernameNotFoundException
    AuthManager --> Controller: AuthenticationException
    Controller --> Client: 401 Unauthorized
else 사용자 존재
    DB --> UserRepo: User
    UserRepo --> Service: User
    Service -> Service: toUserDetail(user)
    note right: Spring Security User 생성\n(email, password, authorities)
    Service --> AuthManager: UserDetails

    AuthManager -> AuthManager: 비밀번호 검증\n(BCrypt)

    alt 비밀번호 불일치
        AuthManager --> Controller: BadCredentialsException
        Controller --> Client: 401 Unauthorized
    else 비밀번호 일치
        AuthManager --> Controller: Authentication (인증 완료)

        Controller -> Security: setAuthentication(auth)
        note right: SecurityContext에\n인증 정보 저장

        Controller -> Controller: request.getSession()\n.setAttribute(CONTEXT_KEY, context)
        note right: 세션에 SecurityContext 저장

        Controller --> Client: 200 OK\n+ Set-Cookie: JSESSIONID
    end
end

@enduml
